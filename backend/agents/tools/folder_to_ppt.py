import os
import logging
import json
from pathlib import Path
from typing import Dict, Any, List

try:
    from pptx import Presentation
    from pptx.util import Inches, Pt
    from pptx.dml.color import RGBColor
    from pptx.enum.text import PP_ALIGN
    HAS_PPTX = True
except ImportError:
    HAS_PPTX = False

from agents.tools.registry import registry, ToolRiskLevel
from core.model_providers import ProviderRegistry

logger = logging.getLogger(__name__)

# Extensions to consider for text analysis
ALLOWED_EXTENSIONS = {
    ".txt", ".md", ".py", ".js", ".html", ".css", ".csv", ".json", 
    ".java", ".cpp", ".c", ".h", ".go", ".rs", ".ts", ".jsx", ".tsx",
    ".sh", ".yml", ".yaml", ".ini", ".conf", ".xml"
}

def analyze_folder_content(folder_path: str) -> str:
    """Reads all allowed files in a folder and creates a consolidated text summary."""
    folder = Path(folder_path)
    if not folder.exists() or not folder.is_dir():
        raise ValueError(f"Invalid folder path: {folder_path}")

    consolidated_text = []
    total_size_read = 0
    MAX_SIZE = 500 * 1024  # Max 500KB total text to avoid massive token bloat

    for root, _, files in os.walk(folder):
        for file in files:
            file_path = Path(root) / file
            
            # Skip hidden files
            if file.startswith('.') or any(p.startswith('.') for p in file_path.parts):
                continue
                
            if file_path.suffix.lower() not in ALLOWED_EXTENSIONS and file_path.suffix != "":
                continue

            try:
                # Read file size first
                size = file_path.stat().st_size
                if size > 100 * 1024:  # Skip files larger than 100KB individually
                    continue
                    
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                    
                total_size_read += len(content)
                if total_size_read > MAX_SIZE:
                    break
                    
                rel_path = file_path.relative_to(folder)
                consolidated_text.append(f"--- FILE: {rel_path} ---\n{content[:2000]}\n") # truncate each file to 2k chars
            except Exception as e:
                logger.debug(f"Skipping {file_path} due to read error: {e}")
                
        if total_size_read > MAX_SIZE:
            consolidated_text.append("\n[NOTE: FOLDER CONTENT TRUNCATED DUE TO SIZE]")
            break

    if not consolidated_text:
        return "No readable text files found in the folder."
        
    return "\n".join(consolidated_text)


import re

def generate_presentation_structure(folder_text: str, title: str) -> List[Dict[str, Any]]:
    """Uses the LLM to analyze the folder content and structure it into slides."""
    registry = ProviderRegistry.auto_detect()
    generate_fn = registry.generate_fn()
    
    prompt = f"""You are a professional presentation creator. Analyze the provided folder contents and create a structured Presentation Outline about the overall project/folder.
Title of Presentation: {title}

FOLDER CONTENT:
{folder_text[:30000]}  # limit text passed to prompt

Create a highly professional slide deck structure with 5 to 10 slides.
Return ONLY a valid JSON array of slide objects. Do not include markdown formatting like ```json.
Each slide object must have:
- "title": (string) Slide title
- "bullets": (list of strings) 3-5 key points for the slide

JSON FORMAT EXAMPLE:
[
  {{"title": "Introduction", "bullets": ["Point 1", "Point 2"]}},
  {{"title": "Architecture", "bullets": ["Detail 1", "Detail 2"]}}
]
"""
    try:
        response = generate_fn(prompt)
        # cleanup markdown JSON formatting if present
        response = response.strip()
        
        # Use regex to find the JSON array in case there's conversational text
        match = re.search(r'\[.*\]', response, re.DOTALL)
        if match:
            json_str = match.group(0)
        else:
            json_str = response
            
        slides = json.loads(json_str)
        return slides
    except Exception as e:
        logger.error(f"Failed to generate presentation structure: {e}")
        # Fallback structure
        return [
            {"title": "Overview", "bullets": ["Analyzed folder contents", "Extracted key metrics", "Project files discovered"]},
            {"title": "Key Findings", "bullets": ["Several source files analyzed.", "Refer to generated documentation for details."]}
        ]


def build_pptx(slides_data: List[Dict[str, Any]], title: str, output_path: str):
    """Generates the actual PPTX file using python-pptx."""
    prs = Presentation()
    
    # Title Slide
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    title_shape = slide.shapes.title
    subtitle = slide.placeholders[1]
    
    title_shape.text = title
    subtitle.text = "Generated by Super Agent (Advanced Analysis)"
    
    # Bullet Slides
    bullet_slide_layout = prs.slide_layouts[1]
    for slide_data in slides_data:
        slide = prs.slides.add_slide(bullet_slide_layout)
        shapes = slide.shapes
        
        # Set Title
        title_shape = shapes.title
        title_shape.text = slide_data.get("title", "Slide")
        
        # Add Bullets
        body_shape = shapes.placeholders[1]
        tf = body_shape.text_frame
        
        bullets = slide_data.get("bullets", [])
        if bullets:
            tf.text = bullets[0]
            for bullet in bullets[1:]:
                p = tf.add_paragraph()
                p.text = bullet
                p.level = 0
                
    # Save Presentation
    prs.save(output_path)


@registry.register(
    name="folder_to_ppt",
    description="Analyzes an entire folder deeply and creates a professional PowerPoint (.pptx) presentation summarizing its contents.",
    risk_level=ToolRiskLevel.MEDIUM,
    parameters={
        "type": "object",
        "properties": {
            "folder_path": {
                "type": "string",
                "description": "Absolute path to the folder to deeply analyze."
            },
            "output_path": {
                "type": "string",
                "description": "Path to save the generated .pptx file (must end in .pptx)."
            },
            "presentation_title": {
                "type": "string",
                "description": "Title of the presentation."
            }
        },
        "required": ["folder_path", "output_path", "presentation_title"]
    }
)
def generate_presentation_from_folder(folder_path: str, output_path: str, presentation_title: str) -> Dict[str, Any]:
    """Reads all files in a folder, deeply summarizes them, and builds a PPTX."""
    if not HAS_PPTX:
        return {"error": "python-pptx library is missing. Please install it with 'pip install python-pptx'."}
        
    try:
        # Step 1: Deep analysis of folder
        logger.info(f"Starting deep analysis of folder: {folder_path}")
        folder_text = analyze_folder_content(folder_path)
        
        # Step 2: Use LLM for presentation structure
        logger.info(f"Extracting insights and structuring presentation for: {presentation_title}")
        slides_structure = generate_presentation_structure(folder_text, presentation_title)
        
        # Step 3: Build PPTX
        logger.info("Building .pptx file...")
        build_pptx(slides_structure, presentation_title, output_path)
        
        return {
            "success": True,
            "message": f"Successfully analyzed folder and generated presentation.",
            "output_path": output_path,
            "slides_generated": len(slides_structure),
            "title": presentation_title
        }
    except Exception as e:
        logger.error(f"Error generating presentation: {e}")
        return {"error": str(e)}
